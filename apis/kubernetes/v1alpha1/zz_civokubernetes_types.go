/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CivoKubernetesObservation struct {

	// The API server endpoint of the cluster
	APIEndpoint *string `json:"apiEndpoint,omitempty" tf:"api_endpoint,omitempty"`

	// The timestamp when the cluster was created
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	// The DNS name of the cluster
	DNSEntry *string `json:"dnsEntry,omitempty" tf:"dns_entry,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	InstalledApplications []InstalledApplicationsObservation `json:"installedApplications,omitempty" tf:"installed_applications,omitempty"`

	// The IP address of the master node
	MasterIP *string `json:"masterIp,omitempty" tf:"master_ip,omitempty"`

	// +kubebuilder:validation:Required
	Pools []PoolsObservation `json:"pools,omitempty" tf:"pools,omitempty"`

	// When cluster is ready, this will return `true`
	Ready *bool `json:"ready,omitempty" tf:"ready,omitempty"`

	// Status of the cluster
	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type CivoKubernetesParameters struct {

	// Comma separated list of applications to install. Spaces within application names are fine, but shouldn't be either side of the comma. Application names are case-sensitive; the available applications can be listed with the Civo CLI: 'civo kubernetes applications ls'. If you want to remove a default installed application, prefix it with a '-', e.g. -Traefik. For application that supports plans, you can use 'app_name:app_plan' format e.g. 'Linkerd:Linkerd & Jaeger' or 'MariaDB:5GB'.
	// +kubebuilder:validation:Optional
	Applications *string `json:"applications,omitempty" tf:"applications,omitempty"`

	// The cni for the k3s to install (the default is `flannel`) valid options are `cilium` or `flannel`
	// +kubebuilder:validation:Optional
	Cni *string `json:"cni,omitempty" tf:"cni,omitempty"`

	// The existing firewall ID to use for this cluster
	// +kubebuilder:validation:Required
	FirewallID *string `json:"firewallId" tf:"firewall_id,omitempty"`

	// The version of k3s to install (optional, the default is currently the latest available)
	// +kubebuilder:validation:Optional
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// The network for the cluster, if not declare we use the default one
	// +kubebuilder:validation:Optional
	NetworkID *string `json:"networkId,omitempty" tf:"network_id,omitempty"`

	// The number of instances to create (optional, the default at the time of writing is 3)
	// +kubebuilder:validation:Optional
	NumTargetNodes *float64 `json:"numTargetNodes,omitempty" tf:"num_target_nodes,omitempty"`

	// +kubebuilder:validation:Required
	Pools []PoolsParameters `json:"pools" tf:"pools,omitempty"`

	// The region for the cluster, if not declare we use the region in declared in the provider
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// Space separated list of tags, to be used freely as required
	// +kubebuilder:validation:Optional
	Tags *string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The size of each node (optional, the default is currently g4s.kube.medium)
	// +kubebuilder:validation:Optional
	TargetNodesSize *string `json:"targetNodesSize,omitempty" tf:"target_nodes_size,omitempty"`
}

type InstalledApplicationsObservation struct {
	Application *string `json:"application,omitempty" tf:"application,omitempty"`

	Category *string `json:"category,omitempty" tf:"category,omitempty"`

	Installed *bool `json:"installed,omitempty" tf:"installed,omitempty"`

	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type InstalledApplicationsParameters struct {
}

type PoolsObservation struct {

	// Instance names in the nodepool
	InstanceNames []*string `json:"instanceNames,omitempty" tf:"instance_names,omitempty"`
}

type PoolsParameters struct {

	// Node pool label, if you don't provide one, we will generate one for you
	// +kubebuilder:validation:Optional
	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// Number of nodes in the nodepool
	// +kubebuilder:validation:Required
	NodeCount *float64 `json:"nodeCount" tf:"node_count,omitempty"`

	// Size of the nodes in the nodepool
	// +kubebuilder:validation:Required
	Size *string `json:"size" tf:"size,omitempty"`
}

// CivoKubernetesSpec defines the desired state of CivoKubernetes
type CivoKubernetesSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     CivoKubernetesParameters `json:"forProvider"`
}

// CivoKubernetesStatus defines the observed state of CivoKubernetes.
type CivoKubernetesStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        CivoKubernetesObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// CivoKubernetes is the Schema for the CivoKubernetess API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,civo}
type CivoKubernetes struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              CivoKubernetesSpec   `json:"spec"`
	Status            CivoKubernetesStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// CivoKubernetesList contains a list of CivoKubernetess
type CivoKubernetesList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []CivoKubernetes `json:"items"`
}

// Repository type metadata.
var (
	CivoKubernetes_Kind             = "CivoKubernetes"
	CivoKubernetes_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: CivoKubernetes_Kind}.String()
	CivoKubernetes_KindAPIVersion   = CivoKubernetes_Kind + "." + CRDGroupVersion.String()
	CivoKubernetes_GroupVersionKind = CRDGroupVersion.WithKind(CivoKubernetes_Kind)
)

func init() {
	SchemeBuilder.Register(&CivoKubernetes{}, &CivoKubernetesList{})
}
