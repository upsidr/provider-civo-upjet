/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type EgressRuleObservation struct {

	// The ID of the firewall rule.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type EgressRuleParameters struct {

	// The action of the rule can be allow or deny. When we set the `action = 'allow'`, this is going to add a rule to allow traffic. Similarly, setting `action = 'deny'` will deny the traffic.
	// +kubebuilder:validation:Required
	Action *string `json:"action" tf:"action,omitempty"`

	// The CIDR notation of the other end to affect, or a valid network CIDR (e.g. 0.0.0.0/0 to open for everyone or 1.2.3.4/32 to open just for a specific IP address)
	// +kubebuilder:validation:Required
	Cidr []*string `json:"cidr" tf:"cidr,omitempty"`

	// A string that will be the displayed name/reference for this rule
	// +kubebuilder:validation:Optional
	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// The port or port range to open, can be a single port or a range separated by a dash (`-`), e.g. `80` or `80-443`
	// +kubebuilder:validation:Optional
	PortRange *string `json:"portRange,omitempty" tf:"port_range,omitempty"`

	// The protocol choice from `tcp`, `udp` or `icmp` (the default if unspecified is `tcp`)
	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`
}

type FirewallObservation struct {

	// The egress rules, this is a list of rules that will be applied to the firewall
	// +kubebuilder:validation:Optional
	EgressRule []EgressRuleObservation `json:"egressRule,omitempty" tf:"egress_rule,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The ingress rules, this is a list of rules that will be applied to the firewall
	// +kubebuilder:validation:Optional
	IngressRule []IngressRuleObservation `json:"ingressRule,omitempty" tf:"ingress_rule,omitempty"`
}

type FirewallParameters struct {

	// The create rules flag is used to create the default firewall rules, if is not defined will be set to true, and if you set to false you need to define at least one ingress or egress rule
	// +kubebuilder:validation:Optional
	CreateDefaultRules *bool `json:"createDefaultRules,omitempty" tf:"create_default_rules,omitempty"`

	// The egress rules, this is a list of rules that will be applied to the firewall
	// +kubebuilder:validation:Optional
	EgressRule []EgressRuleParameters `json:"egressRule,omitempty" tf:"egress_rule,omitempty"`

	// The ingress rules, this is a list of rules that will be applied to the firewall
	// +kubebuilder:validation:Optional
	IngressRule []IngressRuleParameters `json:"ingressRule,omitempty" tf:"ingress_rule,omitempty"`

	// The firewall name
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// The firewall network, if is not defined we use the default network
	// +crossplane:generate:reference:type=github.com/upsidr/provider-civo-upjet/apis/civo/v1alpha1.Network
	// +kubebuilder:validation:Optional
	NetworkID *string `json:"networkId,omitempty" tf:"network_id,omitempty"`

	// Reference to a Network in civo to populate networkId.
	// +kubebuilder:validation:Optional
	NetworkIDRef *v1.Reference `json:"networkIdRef,omitempty" tf:"-"`

	// Selector for a Network in civo to populate networkId.
	// +kubebuilder:validation:Optional
	NetworkIDSelector *v1.Selector `json:"networkIdSelector,omitempty" tf:"-"`

	// The firewall region, if is not defined we use the global defined in the provider
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`
}

type IngressRuleObservation struct {

	// The ID of the firewall rule.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type IngressRuleParameters struct {

	// The action of the rule can be allow or deny. When we set the `action = 'allow'`, this is going to add a rule to allow traffic. Similarly, setting `action = 'deny'` will deny the traffic.
	// +kubebuilder:validation:Required
	Action *string `json:"action" tf:"action,omitempty"`

	// The CIDR notation of the other end to affect, or a valid network CIDR (e.g. 0.0.0.0/0 to open for everyone or 1.2.3.4/32 to open just for a specific IP address)
	// +kubebuilder:validation:Required
	Cidr []*string `json:"cidr" tf:"cidr,omitempty"`

	// A string that will be the displayed name/reference for this rule
	// +kubebuilder:validation:Optional
	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// The port or port range to open, can be a single port or a range separated by a dash (`-`), e.g. `80` or `80-443`
	// +kubebuilder:validation:Optional
	PortRange *string `json:"portRange,omitempty" tf:"port_range,omitempty"`

	// The protocol choice from `tcp`, `udp` or `icmp` (the default if unspecified is `tcp`)
	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`
}

// FirewallSpec defines the desired state of Firewall
type FirewallSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     FirewallParameters `json:"forProvider"`
}

// FirewallStatus defines the observed state of Firewall.
type FirewallStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        FirewallObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Firewall is the Schema for the Firewalls API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,civo}
type Firewall struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              FirewallSpec   `json:"spec"`
	Status            FirewallStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// FirewallList contains a list of Firewalls
type FirewallList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Firewall `json:"items"`
}

// Repository type metadata.
var (
	Firewall_Kind             = "Firewall"
	Firewall_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Firewall_Kind}.String()
	Firewall_KindAPIVersion   = Firewall_Kind + "." + CRDGroupVersion.String()
	Firewall_GroupVersionKind = CRDGroupVersion.WithKind(Firewall_Kind)
)

func init() {
	SchemeBuilder.Register(&Firewall{}, &FirewallList{})
}
