/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type InstalledApplicationsObservation struct {
	Application *string `json:"application,omitempty" tf:"application,omitempty"`

	Category *string `json:"category,omitempty" tf:"category,omitempty"`

	Installed *bool `json:"installed,omitempty" tf:"installed,omitempty"`

	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type InstalledApplicationsParameters struct {
}

type KubernetesClusterObservation struct {

	// The API server endpoint of the cluster
	APIEndpoint *string `json:"apiEndpoint,omitempty" tf:"api_endpoint,omitempty"`

	// The timestamp when the cluster was created
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	// The DNS name of the cluster
	DNSEntry *string `json:"dnsEntry,omitempty" tf:"dns_entry,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	InstalledApplications []InstalledApplicationsObservation `json:"installedApplications,omitempty" tf:"installed_applications,omitempty"`

	// The IP address of the master node
	MasterIP *string `json:"masterIp,omitempty" tf:"master_ip,omitempty"`

	// +kubebuilder:validation:Required
	Pools []PoolsObservation `json:"pools,omitempty" tf:"pools,omitempty"`

	// When cluster is ready, this will return `true`
	Ready *bool `json:"ready,omitempty" tf:"ready,omitempty"`

	// Status of the cluster
	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type KubernetesClusterParameters struct {

	// Comma separated list of applications to install. Spaces within application names are fine, but shouldn't be either side of the comma. Application names are case-sensitive; the available applications can be listed with the Civo CLI: 'civo kubernetes applications ls'. If you want to remove a default installed application, prefix it with a '-', e.g. -Traefik. For application that supports plans, you can use 'app_name:app_plan' format e.g. 'Linkerd:Linkerd & Jaeger' or 'MariaDB:5GB'.
	// +kubebuilder:validation:Optional
	Applications *string `json:"applications,omitempty" tf:"applications,omitempty"`

	// The cni for the k3s to install (the default is `flannel`) valid options are `cilium` or `flannel`
	// +kubebuilder:validation:Optional
	Cni *string `json:"cni,omitempty" tf:"cni,omitempty"`

	// The existing firewall ID to use for this cluster
	// +crossplane:generate:reference:type=github.com/upsidr/provider-civo-upjet/apis/civo/v1alpha1.Firewall
	// +kubebuilder:validation:Optional
	FirewallID *string `json:"firewallId,omitempty" tf:"firewall_id,omitempty"`

	// Reference to a Firewall in civo to populate firewallId.
	// +kubebuilder:validation:Optional
	FirewallIDRef *v1.Reference `json:"firewallIdRef,omitempty" tf:"-"`

	// Selector for a Firewall in civo to populate firewallId.
	// +kubebuilder:validation:Optional
	FirewallIDSelector *v1.Selector `json:"firewallIdSelector,omitempty" tf:"-"`

	// The version of k3s to install (optional, the default is currently the latest available)
	// +kubebuilder:validation:Optional
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// Name for your cluster, must be unique within your account
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The network for the cluster, if not declare we use the default one
	// +crossplane:generate:reference:type=github.com/upsidr/provider-civo-upjet/apis/civo/v1alpha1.Network
	// +kubebuilder:validation:Optional
	NetworkID *string `json:"networkId,omitempty" tf:"network_id,omitempty"`

	// Reference to a Network in civo to populate networkId.
	// +kubebuilder:validation:Optional
	NetworkIDRef *v1.Reference `json:"networkIdRef,omitempty" tf:"-"`

	// Selector for a Network in civo to populate networkId.
	// +kubebuilder:validation:Optional
	NetworkIDSelector *v1.Selector `json:"networkIdSelector,omitempty" tf:"-"`

	// The number of instances to create (optional, the default at the time of writing is 3)
	// +kubebuilder:validation:Optional
	NumTargetNodes *float64 `json:"numTargetNodes,omitempty" tf:"num_target_nodes,omitempty"`

	// +kubebuilder:validation:Required
	Pools []PoolsParameters `json:"pools" tf:"pools,omitempty"`

	// The region for the cluster, if not declare we use the region in declared in the provider
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// Space separated list of tags, to be used freely as required
	// +kubebuilder:validation:Optional
	Tags *string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The size of each node (optional, the default is currently g4s.kube.medium)
	// +kubebuilder:validation:Optional
	TargetNodesSize *string `json:"targetNodesSize,omitempty" tf:"target_nodes_size,omitempty"`
}

type PoolsObservation struct {

	// Instance names in the nodepool
	InstanceNames []*string `json:"instanceNames,omitempty" tf:"instance_names,omitempty"`
}

type PoolsParameters struct {

	// Node pool label, if you don't provide one, we will generate one for you
	// +kubebuilder:validation:Optional
	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// Number of nodes in the nodepool
	// +kubebuilder:validation:Required
	NodeCount *float64 `json:"nodeCount" tf:"node_count,omitempty"`

	// Size of the nodes in the nodepool
	// +kubebuilder:validation:Required
	Size *string `json:"size" tf:"size,omitempty"`
}

// KubernetesClusterSpec defines the desired state of KubernetesCluster
type KubernetesClusterSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     KubernetesClusterParameters `json:"forProvider"`
}

// KubernetesClusterStatus defines the observed state of KubernetesCluster.
type KubernetesClusterStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        KubernetesClusterObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// KubernetesCluster is the Schema for the KubernetesClusters API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,civo}
type KubernetesCluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              KubernetesClusterSpec   `json:"spec"`
	Status            KubernetesClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// KubernetesClusterList contains a list of KubernetesClusters
type KubernetesClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []KubernetesCluster `json:"items"`
}

// Repository type metadata.
var (
	KubernetesCluster_Kind             = "KubernetesCluster"
	KubernetesCluster_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: KubernetesCluster_Kind}.String()
	KubernetesCluster_KindAPIVersion   = KubernetesCluster_Kind + "." + CRDGroupVersion.String()
	KubernetesCluster_GroupVersionKind = CRDGroupVersion.WithKind(KubernetesCluster_Kind)
)

func init() {
	SchemeBuilder.Register(&KubernetesCluster{}, &KubernetesClusterList{})
}
